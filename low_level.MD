
indigoghlretool.ex_time_map
indigoghlretool.opmath

опкод - объект символизирующий 15 минут и имеет вид трехзначного кода в формате 0X0 где 0 - цифра, X - буква
1 цифра - день недели, 2 два символа шифр времени
созданные таким образом непрерывные строки позволяют однозначно идентифицировать определенные 15 минут на протяжении 16 часов (можно и больше, но в данном кейсе 16)
диапазоны минут
00-14
15-29
30-44
44-59
часы с 8-22

пример
понедельник 8:00-9:00 в опкодах выглядит так 1А11А21А31А4
также могут быть использованные и короткие версии (нейтральные опкоды)
А1А2А3А4
для конвертации можно использовать функции Mask и Demask

---
Mask(day:int, str|list[str]|tuple[str]|set[str]) - маскирует нейтральные опкоды под опкоды с учетом дня. строками должны быть сплошные строки опкодов. Как пример
Для  8:00-9:00 строка будет А1А2А3A4, а не [А1, А2, А3, А4]
Если нужно передать доступность на протяжении несколько дней

Mask(2. [А1А2А3A4, А1А2А3A4 А1А2А3A4, '', '', '', А1А2А3A4])
Важно! Для корректной работы длины всех итерируемых объектов должны быть равны 7.

---
Demask(str|list[str]|tuple[str]|set[str]) - из 1А11А21А31А4 в А1А2А3A4

---

getMatrixAndBlock(AvailabilityMatrix) - формирует блоки для парсинга, матрицу доступности и набор примитивов для каждого дня сохраненных в текстовом блоке

getObjectPrimitives( [Group|TestLecture] ) - формирует массив сетов с занятыми ячейками

splitToPrimitives(Teacher) - формирует массив сетов с указанными ячейками

get_time_for_lecture(opcode, length) - на основе опкода и длины занятия в опкодах получает отрезок времени

findSequnces(list[str]|tuple[str]|set[str], length) - в каждом элементе ищет все последовательности опкодов длиной в length

extendBlockSequnce(list[str]) - принимает список отсортированніх опкодов и если находит последовательность из 12 то расширяет ее до последовательности из 16
P.S. кто скажет нафига - дам печеньки)